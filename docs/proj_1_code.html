<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>ST558 - Project 1</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">ST558 - Project 1</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Jenna Christensen and Matthew Wasyluk </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="project-1" class="level2">
<h2 class="anchored" data-anchor-id="project-1">Project 1</h2>
<p>In this project, we use the US Census Microdata API to test our knowledge of API querying, data manipulation in Tidyverse, and other related tools and skills in R. We’ll begin by importing the script files where we wrote our code.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">source</span>(<span class="st">"./scripts/api_tools.R"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning: package 'httr' was built under R version 4.2.3</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning: package 'dplyr' was built under R version 4.2.3</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>
Attaching package: 'dplyr'</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>The following objects are masked from 'package:stats':

    filter, lag</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>The following objects are masked from 'package:base':

    intersect, setdiff, setequal, union</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning: package 'purrr' was built under R version 4.2.3</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>
Attaching package: 'purrr'</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>The following object is masked from 'package:jsonlite':

    flatten</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning: package 'tibble' was built under R version 4.2.3</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning: package 'hms' was built under R version 4.2.3</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning: package 'stringr' was built under R version 4.2.3</code></pre>
</div>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">source</span>(<span class="st">"./scripts/summary_function.R"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning: package 'ggplot2' was built under R version 4.2.3</code></pre>
</div>
</div>
</section>
<section id="fetching-data-from-the-census-api" class="level2">
<h2 class="anchored" data-anchor-id="fetching-data-from-the-census-api">Fetching Data from the Census API</h2>
<p>The Census microdata API has a pretty straightforward endpoint. We make a GET request with URL parameters to specify which variables and geographic levels to return. We have a separate R script (/scripts/api_tools.r) that holds the entire functions. One of them fetches raw data, one converts raw data into a tibble, and one dispatches the process when a user provides years, numeric variables, categorical variables, and geographic options as arguments. We check them and warn the user if their input is invalid. Below is an example of the warning and check code we wrote.</p>
<pre><code>cat_vars_checked &lt;- cat_vars[cat_vars %in% AVAILABLE_CAT_VARS]
cat_vars_failed &lt;- cat_vars[!(cat_vars %in% AVAILABLE_CAT_VARS)]
if(length(cat_vars_failed &gt; 0)){
  warning("Invalid categorical variable(s) excluded: ", paste(cat_vars_failed))
}
if(length(num_vars_checked) == 0){
  warning("No valid categorical variables supplied. Using default SEX.")
  cat_vars_checked = DEFAULT_CAT_VARS
}</code></pre>
<p>And here is a portion of our code that builds the URL. It combines several strings that are placed using user input.</p>
<pre><code>prepared_census_url &lt;- paste(PUMS_URL_MAIN_STUB, year, PUMS_URL_ACS_STUB, PUMS_URL_QUERYSTRING_STUB, sep = "")
if(nchar(varstring) &gt; 0){prepared_census_url &lt;-  paste(prepared_census_url, varstring, sep = ",")}
if (nchar(geo_subset) &gt; 0) {prepared_census_url &lt;- paste(prepared_census_url, "&amp;", geo_subset, sep = "")}</code></pre>
<p>Once fetched, the raw JSON response has to be decoded and parsed into a list. We can turn it into a tibble from there.</p>
<pre><code>census_tbl_in_progress &lt;- rawToChar(census_raw) |&gt;  fromJSON()
census_tbl &lt;- as_tibble(census_tbl_in_progress[-1,]) 
colnames(census_tbl) &lt;- census_tbl_in_progress[1,]</code></pre>
<p>The next step is formatting the variables appropriately. Dplyr helps a lot here.</p>
<pre><code>census_tbl &lt;- census_tbl |&gt; 
  mutate(across(all_of(num_col), as.numeric),
         across(all_of(time_col), ~ as.numeric(convert_census_time_strings(.x, cur_column()))),
         across(all_of(cat_col), ~ factorize_column(.x, cur_column())))</code></pre>
<p>Factorize_column and convert_census_time_strings are custom functions that return factors and numeric 24-hour times as hhmm, respectively. They are defined along with some helper functions in /scripts/cat_var_mapping_tools.R. We’ll get to that later in this document.</p>
<p>In all of this, we set defaults where appropriate. The user could get results no matter whether any arguments are provided.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fetch_census_data</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning: The `x` argument of `as_tibble.matrix()` must have unique column names if
`.name_repair` is omitted as of tibble 2.0.0.
ℹ Using compatibility `.name_repair`.</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 6,972 × 5
   PWGTP  AGEP SEX    state  YEAR
   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;  &lt;chr&gt; &lt;dbl&gt;
 1    55    58 Male   02     2022
 2     8    27 Female 02     2022
 3    63    50 Male   02     2022
 4   101    49 Female 02     2022
 5    17    57 Female 02     2022
 6    62    89 Male   02     2022
 7    27    39 Female 02     2022
 8    29    42 Male   02     2022
 9     5    28 Male   02     2022
10    10    16 Male   02     2022
# ℹ 6,962 more rows</code></pre>
</div>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fetch_census_data</span>(<span class="at">cat_vars =</span> <span class="fu">c</span>(<span class="st">"SCHL"</span>), <span class="at">num_vars =</span> <span class="fu">c</span>(<span class="st">"GRPIP"</span>), <span class="at">geo_vars =</span> <span class="fu">c</span>(<span class="st">"DIVISION"</span>), <span class="at">geo_sub =</span> <span class="st">"3"</span>, <span class="at">years =</span> <span class="fu">c</span>(<span class="dv">2014</span>, <span class="dv">2017</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 938,248 × 6
   PWGTP GRPIP SCHL                                      DIVISION division  YEAR
   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;                                     &lt;chr&gt;    &lt;chr&gt;    &lt;dbl&gt;
 1    96     0 Some college, but less than 1 year        3        3         2014
 2   103     0 Regular high school diploma               3        3         2014
 3    17     0 1 or more years of college credit, no de… 3        3         2014
 4    19     0 1 or more years of college credit, no de… 3        3         2014
 5   135    12 Bachelor's degree                         3        3         2014
 6    17     0 Regular high school diploma               3        3         2014
 7    60     0 Regular high school diploma               3        3         2014
 8    95     0 Grade 11                                  3        3         2014
 9    71     0 1 or more years of college credit, no de… 3        3         2014
10    64     0 1 or more years of college credit, no de… 3        3         2014
# ℹ 938,238 more rows</code></pre>
</div>
</div>
<p>One of the bigger problems we came across was that not all census years have the variables we are using. We get an error response, that we handle by warning the user. The proper course of action would then be for the user grab two or more tibbles with separate calls, then row bind them. Our code to handle this is as follows:</p>
<pre><code>if(census_resp$status_code != 200){
  stop(paste("One or more selected variables is not included in the years you have selected. Please consult the census microdata documentation to be sure the years you select support your chosen variables. The API response for year ", 
             year, 
             "failed to recognize variable", 
             strsplit(rawToChar(census_resp$content), " ")[[1]][5]))
}</code></pre>
</section>
<section id="variable-factorization-code" class="level2">
<h2 class="anchored" data-anchor-id="variable-factorization-code">Variable Factorization Code</h2>
<p>Our code to factorize variables consists of 3 steps: use the API to fetch variable raw information, decode and parse the information into a list, and use the list to factorize the variable. Our API call and parsing is similar here to how we fetch the data. We take the names (keys) of the list as our levels and the values as the levels.</p>
<pre><code>factor(strings, levels = names(mapping), labels = as.character(mapping))</code></pre>
<p>For time, the factorization is a bit more interesting, since we’re not creating a factor despite the variables being categorical for any practical purpose. We decided for ease of calculation and consistency to use 24-hour time in hhmm format (where sometimes half-minutes occur due to intervals that are an odd number of minutes, e.g.&nbsp;100 maps to 1:00PM to 1:39PM). Below are some snippets of code that handle string parsing and conversion to a numeric column.</p>
<pre><code>#here strings is a list where the names are levels of time and the values are labels from the census website
begin_times_raw &lt;- substring(strings, 1, 10) |&gt; 
  str_replace_all(c("a\\.m\\." = "AM", "p\\.m\\." = "PM"))
begin_times &lt;- as.numeric(format(strptime(begin_times_raw, format = "%I:%M %p"), "%H%M"))
  
end_times_raw &lt;- substring(strings, 14, 25) |&gt; 
  str_replace_all(c("a\\.m\\." = "AM", "p\\.m\\." = "PM"))
end_times &lt;- as.numeric(format(strptime(end_times_raw, format = "%I:%M %p"), "%H%M"))

times_converted &lt;- end_times - .5 * (end_times - begin_times)
names(times_converted) &lt;- names(strings)</code></pre>
<pre><code>convert_census_time_strings &lt;- function(strings, var){
  times_converted &lt;- extract_var_mappings(var) |&gt; 
    process_census_time_mapping()
  return(sapply(strings, function(x) times_converted[x]))
}</code></pre>
</section>
<section id="summary-function-and-plotting" class="level2">
<h2 class="anchored" data-anchor-id="summary-function-and-plotting">Summary Function and Plotting</h2>
<p>After creating the working URL with proper specification we wrote the summary function to calculate the sample mean and standard deviation, as well as counts for the categorical variables. We computed the numeric calculations using PWGTP as the weights_vector shown below. Both were added to a list under “Numeric Variable Summary” and “Categorical Variable Counts.”</p>
<pre><code>  num_summary &lt;- census_tbl |&gt;
    mutate(across(all_of(num_vars),
                  .fns = list(
                    mean = function(x) {sum(x*PWGTP, na.rm = TRUE) / sum(PWGTP, na.rm = TRUE)},
                    sd = function(x) {sqrt(sum(x^2*PWGTP, na.rm = TRUE) / sum(PWGTP, na.rm = TRUE) - 
                           (sum(x*PWGTP, na.rm = TRUE) / sum(PWGTP, na.rm = TRUE))^2)}),
                    .names = "{.col}_{.fn}")) |&gt;
    list()
  cat_summary &lt;- census_tbl |&gt;
    group_by(across(all_of(cat_vars))) |&gt;
    summarize(count = n()) |&gt;
    list() </code></pre>
<p>We then plotted the summary function using the provided code and some additional arguments to include a proper title and axis labels.</p>
<pre><code>  ggplot(test,
       aes(x = get(cat_vars), y = get(num_vars), weight = PWGTP)) +
    geom_boxplot() +
    labs(title = paste(num_vars, "by", cat_vars),
         x = cat_vars, y = num_vars)</code></pre>
</section>
<section id="testing-everything-together" class="level2">
<h2 class="anchored" data-anchor-id="testing-everything-together">Testing Everything Together</h2>
<p>Suppose we wanted to investigate when and how individuals arrive at work based on their gross rent as percentage of household income over the previous 12 months, using 3 of the most recent available years. We could do the following:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>test_tbl_1 <span class="ot">&lt;-</span> <span class="fu">fetch_census_data</span>(<span class="at">years =</span> <span class="fu">c</span>(<span class="dv">2019</span>, <span class="dv">2021</span>, <span class="dv">2022</span>), <span class="at">cat_vars =</span> <span class="fu">c</span>(<span class="st">"JWTRNS"</span>), <span class="at">num_vars =</span> <span class="fu">c</span>(<span class="st">"GRPIP"</span>, <span class="st">"JWAP"</span>))</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="fu">summary.census</span>(test_tbl_1, <span class="fu">c</span>(<span class="st">"GRPIP"</span>, <span class="st">"JWAP"</span>), <span class="fu">c</span>(<span class="st">"JWTRNS"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$`Numeric Variable Summary`
$`Numeric Variable Summary`[[1]]
# A tibble: 20,046 × 10
   PWGTP GRPIP  JWAP JWTRNS    state  YEAR GRPIP_mean GRPIP_sd JWAP_mean JWAP_sd
   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;     &lt;chr&gt; &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;
 1   275     0  1942 Walked    2      2019       9.09     20.1      471.    673.
 2    54     0   447 Walked    2      2019       9.09     20.1      471.    673.
 3    15     0    NA N/A (not… 2      2019       9.09     20.1      471.    673.
 4     6     0  1242 Walked    2      2019       9.09     20.1      471.    673.
 5    42     0  2317 &lt;NA&gt;      2      2019       9.09     20.1      471.    673.
 6    86     0   717 &lt;NA&gt;      2      2019       9.09     20.1      471.    673.
 7   136     0  2252 &lt;NA&gt;      2      2019       9.09     20.1      471.    673.
 8    21     0   342 Walked    2      2019       9.09     20.1      471.    673.
 9     8     0    NA N/A (not… 2      2019       9.09     20.1      471.    673.
10    34     0    NA N/A (not… 2      2019       9.09     20.1      471.    673.
# ℹ 20,036 more rows


$`Categorical Variable Counts`
$`Categorical Variable Counts`[[1]]
# A tibble: 5 × 2
  JWTRNS                                                                   count
  &lt;fct&gt;                                                                    &lt;int&gt;
1 Worked from home                                                           708
2 N/A (not a worker-not in the labor force, including persons under 16 ye… 11348
3 Other method                                                               619
4 Walked                                                                    1271
5 &lt;NA&gt;                                                                      6100</code></pre>
</div>
</div>
<p>We could also look into the spread of ages recorded in 2022 between males and females.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>test_tbl <span class="ot">&lt;-</span> <span class="fu">fetch_census_data</span>(<span class="at">years =</span> <span class="fu">c</span>(<span class="dv">2022</span>), <span class="at">cat_vars =</span> <span class="fu">c</span>(<span class="st">"SEX"</span>), <span class="at">num_vars =</span> <span class="fu">c</span>(<span class="st">"AGEP"</span>))</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="fu">summary.census</span>(test_tbl, <span class="fu">c</span>(<span class="st">"AGEP"</span>), <span class="fu">c</span>(<span class="st">"SEX"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$`Numeric Variable Summary`
$`Numeric Variable Summary`[[1]]
# A tibble: 6,972 × 7
   PWGTP  AGEP SEX    state  YEAR AGEP_mean AGEP_sd
   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;  &lt;chr&gt; &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;
 1    55    58 Male   02     2022      37.0    22.2
 2     8    27 Female 02     2022      37.0    22.2
 3    63    50 Male   02     2022      37.0    22.2
 4   101    49 Female 02     2022      37.0    22.2
 5    17    57 Female 02     2022      37.0    22.2
 6    62    89 Male   02     2022      37.0    22.2
 7    27    39 Female 02     2022      37.0    22.2
 8    29    42 Male   02     2022      37.0    22.2
 9     5    28 Male   02     2022      37.0    22.2
10    10    16 Male   02     2022      37.0    22.2
# ℹ 6,962 more rows


$`Categorical Variable Counts`
$`Categorical Variable Counts`[[1]]
# A tibble: 2 × 2
  SEX    count
  &lt;fct&gt;  &lt;int&gt;
1 Male    3693
2 Female  3279</code></pre>
</div>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot.census</span>(test_tbl,<span class="st">"AGEP"</span>, <span class="st">"SEX"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="proj_1_code_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>