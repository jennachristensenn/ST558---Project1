[
  {
    "objectID": "proj_1_code.html",
    "href": "proj_1_code.html",
    "title": "ST558 - Project 1",
    "section": "",
    "text": "In this project, we use the US Census Microdata API to test our knowledge of API querying, data manipulation in Tidyverse, and other related tools and skills in R. We’ll begin by importing the script files where we wrote our code.\n\nsource(\"./scripts/api_tools.R\")\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n\n\nAttaching package: 'purrr'\n\n\nThe following object is masked from 'package:jsonlite':\n\n    flatten\n\nsource(\"./scripts/summary_function.R\")"
  },
  {
    "objectID": "proj_1_code.html#project-1",
    "href": "proj_1_code.html#project-1",
    "title": "ST558 - Project 1",
    "section": "",
    "text": "In this project, we use the US Census Microdata API to test our knowledge of API querying, data manipulation in Tidyverse, and other related tools and skills in R. We’ll begin by importing the script files where we wrote our code.\n\nsource(\"./scripts/api_tools.R\")\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n\n\nAttaching package: 'purrr'\n\n\nThe following object is masked from 'package:jsonlite':\n\n    flatten\n\nsource(\"./scripts/summary_function.R\")"
  },
  {
    "objectID": "proj_1_code.html#fetching-data-from-the-census-api",
    "href": "proj_1_code.html#fetching-data-from-the-census-api",
    "title": "ST558 - Project 1",
    "section": "Fetching Data from the Census API",
    "text": "Fetching Data from the Census API\nThe Census microdata API has a pretty straightforward endpoint. We make a GET request with URL parameters to specify which variables and geographic levels to return. We have a separate R script (/scripts/api_tools.r) that holds the entire functions. One of them fetches raw data, one converts raw data into a tibble, and one dispatches the process when a user provides years, numeric variables, categorical variables, and geographic options as arguments. We check them and warn the user if their input is invalid. Below is an example of the warning and check code we wrote.\ncat_vars_checked &lt;- cat_vars[cat_vars %in% AVAILABLE_CAT_VARS]\ncat_vars_failed &lt;- cat_vars[!(cat_vars %in% AVAILABLE_CAT_VARS)]\nif(length(cat_vars_failed &gt; 0)){\n  warning(\"Invalid categorical variable(s) excluded: \", paste(cat_vars_failed))\n}\nif(length(num_vars_checked) == 0){\n  warning(\"No valid categorical variables supplied. Using default SEX.\")\n  cat_vars_checked = DEFAULT_CAT_VARS\n}\nAnd here is a portion of our code that builds the URL. It combines several strings that are placed using user input.\nprepared_census_url &lt;- paste(PUMS_URL_MAIN_STUB, year, PUMS_URL_ACS_STUB, PUMS_URL_QUERYSTRING_STUB, sep = \"\")\nif(nchar(varstring) &gt; 0){prepared_census_url &lt;-  paste(prepared_census_url, varstring, sep = \",\")}\nif (nchar(geo_subset) &gt; 0) {prepared_census_url &lt;- paste(prepared_census_url, \"&\", geo_subset, sep = \"\")}\nOnce fetched, the raw JSON response has to be decoded and parsed into a list. We can turn it into a tibble from there.\ncensus_tbl_in_progress &lt;- rawToChar(census_raw) |&gt;  fromJSON()\ncensus_tbl &lt;- as_tibble(census_tbl_in_progress[-1,]) \ncolnames(census_tbl) &lt;- census_tbl_in_progress[1,]\nThe next step is formatting the variables appropriately. Dplyr helps a lot here.\ncensus_tbl &lt;- census_tbl |&gt; \n  mutate(across(all_of(num_col), as.numeric),\n         across(all_of(time_col), ~ as.numeric(convert_census_time_strings(.x, cur_column()))),\n         across(all_of(cat_col), ~ factorize_column(.x, cur_column())))\nFactorize_column and convert_census_time_strings are custom functions that return factors and numeric 24-hour times as hhmm, respectively. They are defined along with some helper functions in /scripts/cat_var_mapping_tools.R. We’ll get to that later in this document.\nIn all of this, we set defaults where appropriate. The user could get results no matter whether any arguments are provided.\n\nfetch_census_data()\n\nWarning in fetch_census_data(): No valid geographic variables supplied. Using\ndefault ALL.\n\n\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n\n\n# A tibble: 6,972 × 8\n   PWGTP  AGEP SEX    REGION DIVISION ST    state  YEAR\n   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;  &lt;chr&gt;  &lt;chr&gt;    &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt;\n 1    55    58 Male   4      9        02    02     2022\n 2     8    27 Female 4      9        02    02     2022\n 3    63    50 Male   4      9        02    02     2022\n 4   101    49 Female 4      9        02    02     2022\n 5    17    57 Female 4      9        02    02     2022\n 6    62    89 Male   4      9        02    02     2022\n 7    27    39 Female 4      9        02    02     2022\n 8    29    42 Male   4      9        02    02     2022\n 9     5    28 Male   4      9        02    02     2022\n10    10    16 Male   4      9        02    02     2022\n# ℹ 6,962 more rows\n\nfetch_census_data(cat_vars = c(\"SCHL\"), num_vars = c(\"GRPIP\"), geo_vars = c(\"DIVISION\"), geo_sub = \"3\", years = c(2014, 2017))\n\n# A tibble: 938,248 × 6\n   PWGTP GRPIP SCHL                                      DIVISION division  YEAR\n   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;                                     &lt;chr&gt;    &lt;chr&gt;    &lt;dbl&gt;\n 1    96     0 Some college, but less than 1 year        3        3         2014\n 2   103     0 Regular high school diploma               3        3         2014\n 3    17     0 1 or more years of college credit, no de… 3        3         2014\n 4    19     0 1 or more years of college credit, no de… 3        3         2014\n 5   135    12 Bachelor's degree                         3        3         2014\n 6    17     0 Regular high school diploma               3        3         2014\n 7    60     0 Regular high school diploma               3        3         2014\n 8    95     0 Grade 11                                  3        3         2014\n 9    71     0 1 or more years of college credit, no de… 3        3         2014\n10    64     0 1 or more years of college credit, no de… 3        3         2014\n# ℹ 938,238 more rows\n\n\nOne of the bigger problems we came across was that not all census years have the variables we are using. We get an error response, that we handle by warning the user. The proper course of action would then be for the user grab two or more tibbles with separate calls, then row bind them. Our code to handle this is as follows:\nif(census_resp$status_code != 200){\n  stop(paste(\"One or more selected variables is not included in the years you have selected. Please consult the census microdata documentation to be sure the years you select support your chosen variables. The API response for year \", \n             year, \n             \"failed to recognize variable\", \n             strsplit(rawToChar(census_resp$content), \" \")[[1]][5]))\n}"
  },
  {
    "objectID": "proj_1_code.html#variable-factorization-code",
    "href": "proj_1_code.html#variable-factorization-code",
    "title": "ST558 - Project 1",
    "section": "Variable Factorization Code",
    "text": "Variable Factorization Code\nOur code to factorize variables consists of 3 steps: use the API to fetch variable raw information, decode and parse the information into a list, and use the list to factorize the variable. Our API call and parsing is similar here to how we fetch the data. We take the names (keys) of the list as our levels and the values as the levels.\nfactor(strings, levels = names(mapping), labels = as.character(mapping))\nFor time, the factorization is a bit more interesting, since we’re not creating a factor despite the variables being categorical for any practical purpose. We decided for ease of calculation and consistency to use 24-hour time in hhmm format (where sometimes half-minutes occur due to intervals that are an odd number of minutes, e.g. 100 maps to 1:00PM to 1:39PM). Below are some snippets of code that handle string parsing and conversion to a numeric column.\n#here strings is a list where the names are levels of time and the values are labels from the census website\nbegin_times_raw &lt;- substring(strings, 1, 10) |&gt; \n  str_replace_all(c(\"a\\\\.m\\\\.\" = \"AM\", \"p\\\\.m\\\\.\" = \"PM\"))\nbegin_times &lt;- as.numeric(format(strptime(begin_times_raw, format = \"%I:%M %p\"), \"%H%M\"))\n  \nend_times_raw &lt;- substring(strings, 14, 25) |&gt; \n  str_replace_all(c(\"a\\\\.m\\\\.\" = \"AM\", \"p\\\\.m\\\\.\" = \"PM\"))\nend_times &lt;- as.numeric(format(strptime(end_times_raw, format = \"%I:%M %p\"), \"%H%M\"))\n\ntimes_converted &lt;- end_times - .5 * (end_times - begin_times)\nnames(times_converted) &lt;- names(strings)\nconvert_census_time_strings &lt;- function(strings, var){\n  times_converted &lt;- extract_var_mappings(var) |&gt; \n    process_census_time_mapping()\n  return(sapply(strings, function(x) times_converted[x]))\n}"
  },
  {
    "objectID": "proj_1_code.html#testing-everything-together",
    "href": "proj_1_code.html#testing-everything-together",
    "title": "ST558 - Project 1",
    "section": "Testing Everything Together",
    "text": "Testing Everything Together\nSuppose we wanted to investigate when and how individuals arrive at work based on their gross rent as percentage of household income over the previous 12 months, using 3 of the most recent available years. We could do the following:\n\ntest_tbl &lt;- fetch_census_data(years = c(2019, 2021, 2022), cat_vars = c(\"JWTRNS\"), num_vars = c(\"GRPIP\", \"JWAP\"))\n\nWarning in fetch_census_data(years = c(2019, 2021, 2022), cat_vars =\nc(\"JWTRNS\"), : No valid geographic variables supplied. Using default ALL.\n\nsummary(test_tbl, c(\"GRPIP\", \"JWAP\"), c(\"JWTRNS\"))\n\n$`Numeric Variable Summary`\n$`Numeric Variable Summary`[[1]]\n# A tibble: 20,046 × 13\n   PWGTP GRPIP  JWAP JWTRNS         REGION DIVISION ST    state  YEAR GRPIP_mean\n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;          &lt;chr&gt;  &lt;chr&gt;    &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt;      &lt;dbl&gt;\n 1   275     0  1942 Walked         4      9        2     2      2019       9.09\n 2    54     0   447 Walked         4      9        2     2      2019       9.09\n 3    15     0    NA N/A (not a wo… 4      9        2     2      2019       9.09\n 4     6     0  1242 Walked         4      9        2     2      2019       9.09\n 5    42     0  2317 &lt;NA&gt;           4      9        2     2      2019       9.09\n 6    86     0   717 &lt;NA&gt;           4      9        2     2      2019       9.09\n 7   136     0  2252 &lt;NA&gt;           4      9        2     2      2019       9.09\n 8    21     0   342 Walked         4      9        2     2      2019       9.09\n 9     8     0    NA N/A (not a wo… 4      9        2     2      2019       9.09\n10    34     0    NA N/A (not a wo… 4      9        2     2      2019       9.09\n# ℹ 20,036 more rows\n# ℹ 3 more variables: GRPIP_sd &lt;dbl&gt;, JWAP_mean &lt;dbl&gt;, JWAP_sd &lt;dbl&gt;\n\n\n$`Categorical Variable Counts`\n$`Categorical Variable Counts`[[1]]\n# A tibble: 5 × 2\n  JWTRNS                                                                   count\n  &lt;fct&gt;                                                                    &lt;int&gt;\n1 Worked from home                                                           708\n2 N/A (not a worker-not in the labor force, including persons under 16 ye… 11348\n3 Other method                                                               619\n4 Walked                                                                    1271\n5 &lt;NA&gt;                                                                      6100\n\nplot(test_tbl, \"GRPIP\", \"JWTRNS\")\n\nWarning: Computation failed in `stat_boxplot()`.\nCaused by error in `loadNamespace()`:\n! there is no package called 'quantreg'"
  }
]